<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Interactive ROC Curve Explorer</title>
<link href="https://fonts.googleapis.com/css2?family=Crimson+Pro:ital,wght@0,400;0,600;1,400&display=swap" rel="stylesheet">
<style>
  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
  body {
    font-family: 'Crimson Pro', Georgia, serif;
    color: #1a1a1a;
    padding: 1.5em 1em;
    max-width: 720px;
    margin: 0 auto;
  }
  h2 { font-size: 1.4em; font-weight: 600; color: #002FA7; letter-spacing: -0.01em; margin-bottom: 0.2em; }
  .subtitle { font-size: 0.92em; color: #555; margin-bottom: 1.5em; line-height: 1.5; }
  .layout { display: flex; flex-wrap: wrap; gap: 2em; align-items: flex-start; }
  .table-col { flex: 1 1 240px; min-width: 220px; }
  .plot-col { flex: 1 1 320px; min-width: 280px; }

  table { width: 100%; border-collapse: collapse; font-size: 0.88em; }
  thead tr { border-bottom: 2px solid #1a1a1a; }
  th { text-align: left; padding: 6px 8px; font-weight: 600; }
  th.narrow { width: 32px; }
  tbody tr { border-bottom: 1px solid #e5e5e5; }
  td { padding: 4px 8px; }
  td.row-num { color: #999; font-size: 0.9em; }
  td.remove-cell { text-align: center; padding: 4px; }

  input.cell {
    width: 100%; padding: 5px 7px;
    border: 1.5px solid #ccc; border-radius: 3px;
    font-size: 0.95em; font-family: inherit;
    outline: none; transition: border-color 0.15s;
    background: white;
  }
  input.cell:focus { border-color: #002FA7; }
  input.cell.invalid { border-color: #d44; background: #fff5f5; }
  input.cell.invalid:focus { border-color: #d44; }

  button.remove {
    background: none; border: none; cursor: pointer;
    color: #999; font-size: 1.1em; line-height: 1; padding: 2px 4px; font-family: inherit;
  }
  button.remove:disabled { color: #ddd; cursor: default; }

  button.add {
    margin-top: 0.6em; padding: 6px 14px;
    background: #002FA7; color: white; border: none; border-radius: 3px;
    cursor: pointer; font-size: 0.85em; font-family: inherit; font-weight: 600;
    letter-spacing: 0.02em;
  }
  button.add:disabled { background: #ccc; cursor: default; }

  .status { margin-top: 1em; font-size: 0.82em; color: #777; line-height: 1.5; }
  .status .warn { color: #c44; }

  .empty-plot {
    width: 100%; aspect-ratio: 1; max-width: 420px;
    border: 1px solid #ddd; display: flex; align-items: center;
    justify-content: center; color: #aaa; font-size: 0.9em; border-radius: 2px;
  }

  .footer {
    font-size: 0.8em; color: #888; margin-top: 1.5em; line-height: 1.5;
    border-top: 1px solid #eee; padding-top: 1em;
  }
</style>
</head>
<body>

<h2>Interactive ROC Curve Explorer</h2>
<p class="subtitle">Enter ground truth labels (0 or 1) and classifier scores (0–1), then watch the ROC curve update.</p>

<div class="layout">
  <div class="table-col">
    <table>
      <thead><tr><th>#</th><th>Truth</th><th>Score</th><th class="narrow"></th></tr></thead>
      <tbody id="tbody"></tbody>
    </table>
    <button class="add" id="add-btn" onclick="addRow()">+ Add row</button>
    <div class="status" id="status"></div>
  </div>
  <div class="plot-col" id="plot-col"></div>
</div>

<p class="footer">
  <strong>Truth</strong> is the ground truth label (0 = negative, 1 = positive).
  <strong>Score</strong> is the classifier's predicted probability of class 1.
  The curve traces out (FPR, TPR) pairs across all possible thresholds.
</p>

<script>
const KLEIN = "#002FA7";
const SIZE = 420;
const M = { t: 20, r: 20, b: 52, l: 56 };
const IW = SIZE - M.l - M.r, IH = SIZE - M.t - M.b;

let rows = [
  { truth: "1", score: "0.4" },
  { truth: "0", score: "0.7" },
  { truth: "1", score: "0.9" },
  { truth: "0", score: "0.1" },
  { truth: "0", score: "0.2" },
];

function sx(v) { return M.l + v * IW; }
function sy(v) { return M.t + (1 - v) * IH; }

function isValidTruth(v) { return v === "" || v === "0" || v === "1"; }
function isValidScore(v) { if (v === "") return true; const n = parseFloat(v); return !isNaN(n) && n >= 0 && n <= 1; }

function computeROC() {
  const valid = rows
    .map(r => ({ truth: parseFloat(r.truth), score: parseFloat(r.score) }))
    .filter(r => (r.truth === 0 || r.truth === 1) && !isNaN(r.score) && r.score >= 0 && r.score <= 1);

  const totalPos = valid.filter(r => r.truth === 1).length;
  const totalNeg = valid.filter(r => r.truth === 0).length;
  if (totalPos === 0 || totalNeg === 0) return { points: [], auc: 0 };

  const sorted = [...valid].sort((a, b) => a.score - b.score);
  const scores = sorted.map(r => r.score);

  const thresholds = [scores[0] - 0.05];
  for (let i = 0; i < scores.length - 1; i++) thresholds.push((scores[i] + scores[i + 1]) / 2);
  thresholds.push(scores[scores.length - 1] + 0.05);

  const points = thresholds.sort((a, b) => b - a).map(t => {
    let tp = 0, fp = 0;
    for (const r of valid) { if (r.score >= t) { if (r.truth === 1) tp++; else fp++; } }
    return { fpr: fp / totalNeg, tpr: tp / totalPos, threshold: t };
  });

  points.sort((a, b) => a.fpr - b.fpr || a.tpr - b.tpr);

  const deduped = [points[0]];
  for (let i = 1; i < points.length; i++) {
    const p = deduped[deduped.length - 1];
    if (Math.abs(points[i].fpr - p.fpr) > 1e-9 || Math.abs(points[i].tpr - p.tpr) > 1e-9) deduped.push(points[i]);
  }

  let auc = 0;
  for (let i = 1; i < deduped.length; i++) {
    auc += (deduped[i].fpr - deduped[i - 1].fpr) * (deduped[i].tpr + deduped[i - 1].tpr) / 2;
  }

  return { points: deduped, auc };
}

function svgEl(tag, attrs, children) {
  const el = document.createElementNS("http://www.w3.org/2000/svg", tag);
  for (const [k, v] of Object.entries(attrs || {})) {
    if (k === "textContent") el.textContent = v;
    else if (k === "style" && typeof v === "object") Object.assign(el.style, v);
    else el.setAttribute(k, v);
  }
  if (children) for (const c of children) el.appendChild(c);
  return el;
}

function renderPlot() {
  const col = document.getElementById("plot-col");
  const { points, auc } = computeROC();

  if (points.length === 0) {
    col.innerHTML = '<div class="empty-plot">Enter valid data to see the ROC curve</div>';
    return;
  }

  const ticks = [0, 0.2, 0.4, 0.6, 0.8, 1.0];
  const kids = [];

  // background
  kids.push(svgEl("rect", { x: M.l, y: M.t, width: IW, height: IH, fill: "white", stroke: "black", "stroke-width": 1 }));

  // grid
  for (const t of ticks.slice(1, -1)) {
    kids.push(svgEl("line", { x1: sx(t), y1: sy(0), x2: sx(t), y2: sy(1), stroke: "#e0e0e0", "stroke-width": 0.5 }));
    kids.push(svgEl("line", { x1: sx(0), y1: sy(t), x2: sx(1), y2: sy(t), stroke: "#e0e0e0", "stroke-width": 0.5 }));
  }

  // diagonal
  kids.push(svgEl("line", { x1: sx(0), y1: sy(0), x2: sx(1), y2: sy(1), stroke: "black", "stroke-width": 0.8, "stroke-dasharray": "6,4" }));

  // ROC curve
  if (points.length > 1) {
    const d = points.map((p, i) => `${i === 0 ? "M" : "L"}${sx(p.fpr)},${sy(p.tpr)}`).join(" ");
    kids.push(svgEl("path", { d, fill: "none", stroke: KLEIN, "stroke-width": 2.5 }));
  }

  // dots
  for (const p of points) kids.push(svgEl("circle", { cx: sx(p.fpr), cy: sy(p.tpr), r: 4, fill: KLEIN }));

  // x-axis ticks & labels
  for (const t of ticks) {
    kids.push(svgEl("line", { x1: sx(t), y1: sy(0), x2: sx(t), y2: sy(0) + 5, stroke: "black", "stroke-width": 1 }));
    kids.push(svgEl("text", { x: sx(t), y: sy(0) + 18, "text-anchor": "middle", style: { fontSize: "11px", fontFamily: "serif" }, textContent: t.toFixed(1) }));
  }

  // y-axis ticks & labels
  for (const t of ticks) {
    kids.push(svgEl("line", { x1: sx(0) - 5, y1: sy(t), x2: sx(0), y2: sy(t), stroke: "black", "stroke-width": 1 }));
    kids.push(svgEl("text", { x: sx(0) - 9, y: sy(t) + 4, "text-anchor": "end", style: { fontSize: "11px", fontFamily: "serif" }, textContent: t.toFixed(1) }));
  }

  // axis titles
  kids.push(svgEl("text", { x: M.l + IW / 2, y: SIZE - 6, "text-anchor": "middle", style: { fontSize: "13px", fontFamily: "serif" }, textContent: "False Positive Rate" }));
  const yLabel = svgEl("text", { x: 14, y: M.t + IH / 2, "text-anchor": "middle", transform: `rotate(-90, 14, ${M.t + IH / 2})`, style: { fontSize: "13px", fontFamily: "serif" }, textContent: "True Positive Rate" });
  kids.push(yLabel);

  // legend
  const lg = svgEl("g", { transform: `translate(${sx(0.52)}, ${sy(0.18)})` }, [
    svgEl("rect", { x: 0, y: 0, width: 160, height: 44, fill: "white", "fill-opacity": 0.92, stroke: "#ccc", "stroke-width": 0.5, rx: 2 }),
    svgEl("line", { x1: 8, y1: 14, x2: 28, y2: 14, stroke: "black", "stroke-width": 0.8, "stroke-dasharray": "6,4" }),
    svgEl("text", { x: 33, y: 18, style: { fontSize: "10.5px", fontFamily: "serif" }, textContent: "Random (AUC = 0.50)" }),
    svgEl("line", { x1: 8, y1: 32, x2: 28, y2: 32, stroke: KLEIN, "stroke-width": 2.5 }),
    svgEl("circle", { cx: 18, cy: 32, r: 3, fill: KLEIN }),
    svgEl("text", { x: 33, y: 36, style: { fontSize: "10.5px", fontFamily: "serif" }, textContent: `Classifier (AUC = ${auc.toFixed(2)})` }),
  ]);
  kids.push(lg);

  const svg = svgEl("svg", { viewBox: `0 0 ${SIZE} ${SIZE}`, style: { width: "100%", maxWidth: SIZE + "px", height: "auto" } }, kids);
  col.innerHTML = "";
  col.appendChild(svg);
}

function renderTable() {
  const tbody = document.getElementById("tbody");
  tbody.innerHTML = "";

  rows.forEach((row, i) => {
    const tr = document.createElement("tr");

    const tdNum = document.createElement("td");
    tdNum.className = "row-num";
    tdNum.textContent = i + 1;
    tr.appendChild(tdNum);

    // Truth input
    const tdTruth = document.createElement("td");
    const inTruth = document.createElement("input");
    inTruth.type = "text"; inTruth.inputMode = "decimal";
    inTruth.className = "cell" + (isValidTruth(row.truth) ? "" : " invalid");
    inTruth.value = row.truth; inTruth.placeholder = "0 or 1";
    inTruth.addEventListener("input", () => { rows[i].truth = inTruth.value; update(); });
    tdTruth.appendChild(inTruth);
    tr.appendChild(tdTruth);

    // Score input
    const tdScore = document.createElement("td");
    const inScore = document.createElement("input");
    inScore.type = "text"; inScore.inputMode = "decimal";
    inScore.className = "cell" + (isValidScore(row.score) ? "" : " invalid");
    inScore.value = row.score; inScore.placeholder = "0.0–1.0";
    inScore.addEventListener("input", () => { rows[i].score = inScore.value; update(); });
    tdScore.appendChild(inScore);
    tr.appendChild(tdScore);

    // Remove button
    const tdRm = document.createElement("td");
    tdRm.className = "remove-cell";
    const btn = document.createElement("button");
    btn.className = "remove"; btn.textContent = "×"; btn.title = "Remove row";
    btn.disabled = rows.length <= 2;
    btn.addEventListener("click", () => { if (rows.length > 2) { rows.splice(i, 1); renderTable(); renderPlot(); updateStatus(); } });
    tdRm.appendChild(btn);
    tr.appendChild(tdRm);

    tbody.appendChild(tr);
  });

  document.getElementById("add-btn").disabled = rows.length >= 10;
}

function updateStatus() {
  const validCount = rows.filter(r => {
    const t = parseFloat(r.truth), s = parseFloat(r.score);
    return (t === 0 || t === 1) && !isNaN(s) && s >= 0 && s <= 1;
  }).length;
  const hasPos = rows.some(r => parseFloat(r.truth) === 1);
  const hasNeg = rows.some(r => parseFloat(r.truth) === 0);
  let html = `${validCount} valid sample${validCount !== 1 ? "s" : ""}`;
  if (validCount > 0 && (!hasPos || !hasNeg)) html += ' <span class="warn">— need both classes (0 and 1) for ROC</span>';
  document.getElementById("status").innerHTML = html;
}

function update() {
  // Update validity classes without full re-render (preserve focus)
  const inputs = document.querySelectorAll("#tbody input.cell");
  rows.forEach((row, i) => {
    const truthInput = inputs[i * 2];
    const scoreInput = inputs[i * 2 + 1];
    if (truthInput) truthInput.className = "cell" + (isValidTruth(row.truth) ? "" : " invalid");
    if (scoreInput) scoreInput.className = "cell" + (isValidScore(row.score) ? "" : " invalid");
  });
  renderPlot();
  updateStatus();
}

function addRow() {
  if (rows.length < 10) { rows.push({ truth: "", score: "" }); renderTable(); renderPlot(); updateStatus(); }
}

renderTable();
renderPlot();
updateStatus();
</script>
</body>
</html>